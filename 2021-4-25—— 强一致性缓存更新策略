强一致性缓存更新策略

目标
1.数据库与缓存一致性问题
A.AP和CP选哪个，极端情况下报C还是保A.
B.Transaction对Master数据的使用仅涉及读锁，属于不可重复读问题，如果要解决只能考虑线性处理 Serializable ，Master更新操作要对Transaction产生制御，如果不需要，则不考虑，后续也不要把这个问题牵扯进来。
C.一致性要一体化考虑，缓存和数据库应该视为以个整体考虑对策，然后再细化。
D.将整体视为资源，现状是我们对这个资源有并发读写操作。保证整体一致性，我们要限制读写操作，这是一个标准的并发读写模型问题，我们要写阻塞读，并且一写多读。目标是保C，宁可一段时间不走缓存只走数据库。
具体表现在，Master缓存，Master 内部读操作只从数据库取数据。
Master 数据保存，需要外层事物里层缓存，里层缓存只做删除操作，缓存删除失败外部事物回滚。通过这个操作确保缓存一定与数据库一致，最多缓存比数据库缺少数据，但没有数据多版本问题，我们会确保这个机制只在画面端有效，不影响Batch。
Transaction 缓存，先从缓存拉数据没有取数据库的数据，数据库的数据取到了也不更新缓存。
全局只在定时任务中新增缓存，Master 仅删除，Transaction 仅查询不更新。解决数据多版本问题，确保缓存数据范围小于等于数据库。

2.缓存集群内部一致性问题解决
主从同步，按更新时间定时更新，每次更新一个小段，每次更新记录同步范围。
同步反馈，主从同步通过命令Pipeline+Wait判断本次批量提交是否成功。
同步反馈失败应对，首先多次尝试同步，持续失败打印Warning ，超过一定与次数，尝试删除缓存，删除失败打印error。如果期间发生Master宕机，则slave是安全的，因为只存在新增数据未同步，更新数据操作在Master用户端已经被拦下来了。因为Master用户端更新成功，缓存一定先删除，如果删除失败数据库会回滚，这个时候缓存与数据库是一致的，如果删除部分成功但slave 同步失败，也没大问题，因为Slave 此时和数据库是一致的，而Master丢失了对应数据，虽然Master和Slave不一致，但是无影响。

但最好通过定时社区新策略恢复一致。

3.数据刷新策略
缓存写入与Master更新制御
在数据定时刷新服务中定时写入缓存，这个是全局唯一的写入操作，该过程需要对Master制御，但是对transaction开放。因为有制御保证，所以写过程，transaction从缓存还是数据库读取数据都是一样的，不需要阻塞。
设置一个数据库标记，从Master写入数据时到完成后两分钟内，制御缓存刷新。每次有新的Master写入就刷新时间，最多不超过两分钟。缓存写入时，反向制御Master，避免写冲突，缩短同步时间，拉长同步间隔，或者白天不同步，每日固定时间做同步。
批处理过程，遵守相同的策略，单独控制。


4.对外提供的交付物
A.缓存注解，支持Master和Transaction配置，支持web和批处理自动识别并区分配置。
B.定时批量缓存更新服务，支持注解与更新服务间的制御
C.redis 故障恢复手顺和影响分析报告
